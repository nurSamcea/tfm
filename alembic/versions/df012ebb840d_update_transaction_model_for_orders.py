"""update_transaction_model_for_orders

Revision ID: df012ebb840d
Revises: fake_category_enum
Create Date: 2025-09-06 22:22:25.517244

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'df012ebb840d'
down_revision: Union[str, None] = 'fake_category_enum'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    # Crear el enum primero
    blockchainentitytypeenum = sa.Enum('product', 'transaction', 'sensor', name='blockchainentitytypeenum')
    blockchainentitytypeenum.create(op.get_bind())
    
    op.add_column('blockchain_logs', sa.Column('entity_type', blockchainentitytypeenum, nullable=True))
    op.add_column('blockchain_logs', sa.Column('entity_id', sa.Integer(), nullable=True))
    op.add_column('blockchain_logs', sa.Column('hash', sa.Text(), nullable=True))
    op.drop_constraint('blockchain_logs_transaction_hash_key', 'blockchain_logs', type_='unique')
    op.drop_index('idx_blockchain_logs_action', table_name='blockchain_logs')
    op.drop_index('idx_blockchain_logs_hash', table_name='blockchain_logs')
    op.drop_index('idx_blockchain_logs_product', table_name='blockchain_logs')
    op.drop_constraint('blockchain_logs_product_id_fkey', 'blockchain_logs', type_='foreignkey')
    op.drop_column('blockchain_logs', 'data')
    op.drop_column('blockchain_logs', 'action')
    op.drop_column('blockchain_logs', 'block_number')
    op.drop_column('blockchain_logs', 'transaction_hash')
    op.drop_column('blockchain_logs', 'product_id')
    op.add_column('impact_metrics', sa.Column('co2_saved_kg', sa.Float(), nullable=True))
    op.add_column('impact_metrics', sa.Column('local_support_eur', sa.Float(), nullable=True))
    op.add_column('impact_metrics', sa.Column('waste_prevented_kg', sa.Float(), nullable=True))
    op.add_column('impact_metrics', sa.Column('nutritional_consumption', sa.Float(), nullable=True))
    op.drop_index('idx_impact_metrics_product', table_name='impact_metrics')
    op.drop_index('idx_impact_metrics_type', table_name='impact_metrics')
    op.drop_index('idx_impact_metrics_user', table_name='impact_metrics')
    op.drop_constraint('impact_metrics_product_id_fkey', 'impact_metrics', type_='foreignkey')
    op.drop_column('impact_metrics', 'metric_type')
    op.drop_column('impact_metrics', 'value')
    op.drop_column('impact_metrics', 'unit')
    op.drop_column('impact_metrics', 'created_at')
    op.drop_column('impact_metrics', 'product_id')
    op.drop_column('impact_metrics', 'calculation_date')
    op.alter_column('products', 'is_hidden',
               existing_type=sa.BOOLEAN(),
               nullable=True,
               existing_server_default=sa.text('false'))
    op.drop_index('idx_products_category', table_name='products')
    op.drop_index('idx_products_name', table_name='products')
    op.drop_index('idx_products_provider', table_name='products')
    op.drop_column('products', 'updated_at')
    op.add_column('qrs', sa.Column('qr_hash', sa.Text(), nullable=True))
    op.add_column('qrs', sa.Column('qr_metadata', sa.JSON(), nullable=True))
    op.add_column('qrs', sa.Column('qr_type', sa.Text(), nullable=True))
    op.drop_index('idx_qrs_code', table_name='qrs')
    op.drop_index('idx_qrs_product', table_name='qrs')
    op.drop_constraint('qrs_qr_code_key', 'qrs', type_='unique')
    op.drop_column('qrs', 'qr_code')
    op.drop_column('qrs', 'is_active')
    op.drop_column('qrs', 'url')
    op.add_column('sensor_readings', sa.Column('product_id', sa.Integer(), nullable=True))
    op.add_column('sensor_readings', sa.Column('temperature', sa.Float(), nullable=True))
    op.add_column('sensor_readings', sa.Column('humidity', sa.Float(), nullable=True))
    op.add_column('sensor_readings', sa.Column('gas_level', sa.Float(), nullable=True))
    op.add_column('sensor_readings', sa.Column('light_level', sa.Float(), nullable=True))
    op.add_column('sensor_readings', sa.Column('shock_detected', sa.Boolean(), nullable=True))
    op.add_column('sensor_readings', sa.Column('created_at', sa.DateTime(), nullable=True))
    op.add_column('sensor_readings', sa.Column('source_device', sa.Text(), nullable=True))
    # Crear el enum de tipo de sensor primero (incluyendo todos los valores posibles)
    sensortypeenum = sa.Enum('temperature', 'humidity', 'gas', 'light', 'shock', 'gps', 'soil_moisture', 'pressure', 'ph', 'co2', 'noise', 'vibration', 'light_intensity', 'air_quality', 'motion', 'proximity', 'weight', 'flow', 'level', 'speed', 'direction', 'altitude', 'battery', 'signal_strength', 'other', name='sensortypeenum')
    sensortypeenum.create(op.get_bind())
    
    op.alter_column('sensor_readings', 'sensor_type',
               existing_type=sa.TEXT(),
               type_=sensortypeenum,
               nullable=True,
               postgresql_using='sensor_type::sensortypeenum')
    op.drop_index('idx_sensor_readings_sensor', table_name='sensor_readings')
    op.drop_index('idx_sensor_readings_timestamp', table_name='sensor_readings')
    op.drop_index('idx_sensor_readings_type', table_name='sensor_readings')
    op.create_foreign_key(None, 'sensor_readings', 'products', ['product_id'], ['id'])
    op.drop_column('sensor_readings', 'sensor_id')
    op.drop_column('sensor_readings', 'value')
    op.drop_column('sensor_readings', 'unit')
    op.drop_column('sensor_readings', 'timestamp')
    op.drop_column('sensor_readings', 'location_lat')
    op.drop_column('sensor_readings', 'metadata')
    op.drop_column('sensor_readings', 'location_lon')
    op.alter_column('shopping_list_groups', 'shopping_list_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('shopping_list_groups', 'provider_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.drop_index('idx_shopping_list_groups_list', table_name='shopping_list_groups')
    op.drop_index('idx_shopping_list_groups_provider', table_name='shopping_list_groups')
    op.drop_constraint('shopping_list_groups_shopping_list_id_fkey', 'shopping_list_groups', type_='foreignkey')
    op.create_foreign_key(None, 'shopping_list_groups', 'shopping_lists', ['shopping_list_id'], ['id'])
    op.drop_column('shopping_list_groups', 'created_at')
    op.alter_column('shopping_list_items', 'shopping_list_group_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('shopping_list_items', 'product_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('shopping_list_items', 'quantity',
               existing_type=sa.DOUBLE_PRECISION(precision=53),
               nullable=True,
               existing_server_default=sa.text('1'))
    op.drop_index('idx_shopping_list_items_group', table_name='shopping_list_items')
    op.drop_index('idx_shopping_list_items_product', table_name='shopping_list_items')
    op.drop_constraint('shopping_list_items_shopping_list_group_id_fkey', 'shopping_list_items', type_='foreignkey')
    op.create_foreign_key(None, 'shopping_list_items', 'shopping_list_groups', ['shopping_list_group_id'], ['id'])
    op.alter_column('shopping_lists', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    # Crear el enum de estado de lista de compras primero
    shoppingliststatusenum = sa.Enum('draft', 'pending', 'paid', 'delivered', 'cancelled', name='shoppingliststatusenum')
    shoppingliststatusenum.create(op.get_bind())
    
    # Primero eliminar el valor por defecto existente
    op.alter_column('shopping_lists', 'status', server_default=None)
    
    # Luego cambiar el tipo de columna
    op.alter_column('shopping_lists', 'status',
               existing_type=sa.TEXT(),
               type_=shoppingliststatusenum,
               nullable=False,
               postgresql_using='status::shoppingliststatusenum')
    
    # Finalmente agregar el nuevo valor por defecto
    op.alter_column('shopping_lists', 'status', server_default=sa.text("'draft'::shoppingliststatusenum"))
    op.drop_index('idx_shopping_lists_status', table_name='shopping_lists')
    op.drop_index('idx_shopping_lists_user', table_name='shopping_lists')
    op.drop_constraint('shopping_lists_user_id_fkey', 'shopping_lists', type_='foreignkey')
    op.create_foreign_key(None, 'shopping_lists', 'users', ['user_id'], ['id'])
    op.drop_column('shopping_lists', 'updated_at')
    # Crear el enum de estado de transacción primero (incluyendo todos los valores posibles)
    transactionstatusenum = sa.Enum('pending', 'in_progress', 'delivered', 'cancelled', 'completed', name='transactionstatusenum')
    transactionstatusenum.create(op.get_bind())
    
    # Agregar columnas como nullable primero
    op.add_column('transactions', sa.Column('buyer_id', sa.Integer(), nullable=True))
    op.add_column('transactions', sa.Column('seller_id', sa.Integer(), nullable=True))
    op.add_column('transactions', sa.Column('buyer_type', sa.Text(), nullable=True))
    op.add_column('transactions', sa.Column('seller_type', sa.Text(), nullable=True))
    
    # Llenar los datos existentes (asumiendo que user_id era el buyer)
    # Para seller_id, necesitamos un valor por defecto. Usaremos el primer usuario farmer disponible
    op.execute("""
        UPDATE transactions 
        SET buyer_id = user_id, 
            buyer_type = 'consumer', 
            seller_id = (SELECT id FROM users WHERE role = 'farmer' LIMIT 1),
            seller_type = 'farmer' 
        WHERE buyer_id IS NULL
    """)
    
    # Ahora hacer las columnas NOT NULL
    op.alter_column('transactions', 'buyer_id', nullable=False)
    op.alter_column('transactions', 'seller_id', nullable=False)
    op.alter_column('transactions', 'buyer_type', nullable=False)
    op.alter_column('transactions', 'seller_type', nullable=False)
    # Agregar columnas como nullable primero
    op.add_column('transactions', sa.Column('total_price', sa.DECIMAL(), nullable=True))
    op.add_column('transactions', sa.Column('confirmed_at', sa.DateTime(), nullable=True))
    op.add_column('transactions', sa.Column('delivered_at', sa.DateTime(), nullable=True))
    op.add_column('transactions', sa.Column('order_details', sa.JSON(), nullable=True))
    
    # Llenar los datos existentes
    op.execute("UPDATE transactions SET total_price = amount, order_details = '{}' WHERE total_price IS NULL")
    
    # Ahora hacer las columnas NOT NULL
    op.alter_column('transactions', 'total_price', nullable=False)
    op.alter_column('transactions', 'order_details', nullable=False)
    # Primero eliminar el valor por defecto existente
    op.alter_column('transactions', 'status', server_default=None)
    
    # Luego cambiar el tipo de columna
    op.alter_column('transactions', 'status',
               existing_type=sa.TEXT(),
               type_=transactionstatusenum,
               nullable=False,
               postgresql_using='status::transactionstatusenum')
    
    # Finalmente agregar el nuevo valor por defecto
    op.alter_column('transactions', 'status', server_default=sa.text("'pending'::transactionstatusenum"))
    op.drop_index('idx_transactions_status', table_name='transactions')
    op.drop_index('idx_transactions_user', table_name='transactions')
    op.drop_constraint('transactions_shopping_list_id_fkey', 'transactions', type_='foreignkey')
    op.drop_constraint('transactions_user_id_fkey', 'transactions', type_='foreignkey')
    op.create_foreign_key(None, 'transactions', 'users', ['buyer_id'], ['id'])
    op.create_foreign_key(None, 'transactions', 'users', ['seller_id'], ['id'])
    op.drop_column('transactions', 'user_id')
    op.drop_column('transactions', 'amount')
    op.drop_column('transactions', 'transaction_hash')
    op.drop_column('transactions', 'shopping_list_id')
    op.drop_column('transactions', 'payment_method')
    # Crear el enum de rol de usuario primero (incluyendo valores legacy para migración)
    userroleenum = sa.Enum('consumer', 'farmer', 'supermarket', 'retailer', 'admin', name='userroleenum')
    userroleenum.create(op.get_bind())
    
    # Convertir valores legacy antes de cambiar el tipo
    op.execute("UPDATE users SET role = 'supermarket' WHERE role = 'retailer'")
    op.execute("UPDATE users SET role = 'consumer' WHERE role = 'admin'")
    
    # Primero eliminar el valor por defecto existente
    op.alter_column('users', 'role', server_default=None)
    
    # Luego cambiar el tipo de columna
    op.alter_column('users', 'role',
               existing_type=sa.TEXT(),
               type_=userroleenum,
               existing_nullable=False,
               postgresql_using='role::userroleenum')
    
    # Finalmente agregar el nuevo valor por defecto
    op.alter_column('users', 'role', server_default=sa.text("'consumer'::userroleenum"))
    op.drop_index('idx_users_email', table_name='users')
    op.drop_index('idx_users_role', table_name='users')
    op.drop_constraint('users_email_key', 'users', type_='unique')
    op.create_index('ix_users_email', 'users', ['email'], unique=False)
    op.drop_column('users', 'is_active')
    op.drop_column('users', 'updated_at')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.add_column('users', sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=True))
    op.drop_index('ix_users_email', table_name='users')
    op.create_unique_constraint('users_email_key', 'users', ['email'], postgresql_nulls_not_distinct=False)
    op.create_index('idx_users_role', 'users', ['role'], unique=False)
    op.create_index('idx_users_email', 'users', ['email'], unique=False)
    op.alter_column('users', 'role',
               existing_type=sa.Enum('consumer', 'farmer', 'supermarket', 'retailer', 'admin', name='userroleenum'),
               type_=sa.TEXT(),
               existing_nullable=False,
               existing_server_default=sa.text("'consumer'::text"))
    
    # Eliminar el enum de rol de usuario
    userroleenum = sa.Enum('consumer', 'farmer', 'supermarket', 'retailer', 'admin', name='userroleenum')
    userroleenum.drop(op.get_bind())
    op.add_column('transactions', sa.Column('payment_method', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('transactions', sa.Column('shopping_list_id', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('transactions', sa.Column('transaction_hash', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('transactions', sa.Column('amount', sa.NUMERIC(), autoincrement=False, nullable=False))
    op.add_column('transactions', sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=False))
    op.drop_constraint(None, 'transactions', type_='foreignkey')
    op.drop_constraint(None, 'transactions', type_='foreignkey')
    op.create_foreign_key('transactions_user_id_fkey', 'transactions', 'users', ['user_id'], ['id'])
    op.create_foreign_key('transactions_shopping_list_id_fkey', 'transactions', 'shopping_lists', ['shopping_list_id'], ['id'])
    op.create_index('idx_transactions_user', 'transactions', ['user_id'], unique=False)
    op.create_index('idx_transactions_status', 'transactions', ['status'], unique=False)
    op.alter_column('transactions', 'status',
               existing_type=sa.Enum('pending', 'in_progress', 'delivered', 'cancelled', 'completed', name='transactionstatusenum'),
               type_=sa.TEXT(),
               nullable=True,
               existing_server_default=sa.text("'pending'::text"))
    op.drop_column('transactions', 'order_details')
    op.drop_column('transactions', 'delivered_at')
    op.drop_column('transactions', 'confirmed_at')
    op.drop_column('transactions', 'total_price')
    op.drop_column('transactions', 'seller_type')
    op.drop_column('transactions', 'buyer_type')
    op.drop_column('transactions', 'seller_id')
    op.drop_column('transactions', 'buyer_id')
    
    # Eliminar el enum de estado de transacción
    transactionstatusenum = sa.Enum('pending', 'in_progress', 'delivered', 'cancelled', 'completed', name='transactionstatusenum')
    transactionstatusenum.drop(op.get_bind())
    op.add_column('shopping_lists', sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'shopping_lists', type_='foreignkey')
    op.create_foreign_key('shopping_lists_user_id_fkey', 'shopping_lists', 'users', ['user_id'], ['id'], ondelete='CASCADE')
    op.create_index('idx_shopping_lists_user', 'shopping_lists', ['user_id'], unique=False)
    op.create_index('idx_shopping_lists_status', 'shopping_lists', ['status'], unique=False)
    op.alter_column('shopping_lists', 'status',
               existing_type=sa.Enum('draft', 'pending', 'paid', 'delivered', 'cancelled', name='shoppingliststatusenum'),
               type_=sa.TEXT(),
               nullable=True,
               existing_server_default=sa.text("'draft'::text"))
    
    # Eliminar el enum de estado de lista de compras
    shoppingliststatusenum = sa.Enum('draft', 'pending', 'paid', 'delivered', 'cancelled', name='shoppingliststatusenum')
    shoppingliststatusenum.drop(op.get_bind())
    op.alter_column('shopping_lists', 'user_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.drop_constraint(None, 'shopping_list_items', type_='foreignkey')
    op.create_foreign_key('shopping_list_items_shopping_list_group_id_fkey', 'shopping_list_items', 'shopping_list_groups', ['shopping_list_group_id'], ['id'], ondelete='CASCADE')
    op.create_index('idx_shopping_list_items_product', 'shopping_list_items', ['product_id'], unique=False)
    op.create_index('idx_shopping_list_items_group', 'shopping_list_items', ['shopping_list_group_id'], unique=False)
    op.alter_column('shopping_list_items', 'quantity',
               existing_type=sa.DOUBLE_PRECISION(precision=53),
               nullable=False,
               existing_server_default=sa.text('1'))
    op.alter_column('shopping_list_items', 'product_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('shopping_list_items', 'shopping_list_group_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.add_column('shopping_list_groups', sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.drop_constraint(None, 'shopping_list_groups', type_='foreignkey')
    op.create_foreign_key('shopping_list_groups_shopping_list_id_fkey', 'shopping_list_groups', 'shopping_lists', ['shopping_list_id'], ['id'], ondelete='CASCADE')
    op.create_index('idx_shopping_list_groups_provider', 'shopping_list_groups', ['provider_id'], unique=False)
    op.create_index('idx_shopping_list_groups_list', 'shopping_list_groups', ['shopping_list_id'], unique=False)
    op.alter_column('shopping_list_groups', 'provider_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('shopping_list_groups', 'shopping_list_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.add_column('sensor_readings', sa.Column('location_lon', sa.NUMERIC(), autoincrement=False, nullable=True))
    op.add_column('sensor_readings', sa.Column('metadata', postgresql.JSON(astext_type=sa.Text()), server_default=sa.text("'{}'::json"), autoincrement=False, nullable=True))
    op.add_column('sensor_readings', sa.Column('location_lat', sa.NUMERIC(), autoincrement=False, nullable=True))
    op.add_column('sensor_readings', sa.Column('timestamp', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.add_column('sensor_readings', sa.Column('unit', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('sensor_readings', sa.Column('value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
    op.add_column('sensor_readings', sa.Column('sensor_id', sa.TEXT(), autoincrement=False, nullable=False))
    op.drop_constraint(None, 'sensor_readings', type_='foreignkey')
    op.create_index('idx_sensor_readings_type', 'sensor_readings', ['sensor_type'], unique=False)
    op.create_index('idx_sensor_readings_timestamp', 'sensor_readings', ['timestamp'], unique=False)
    op.create_index('idx_sensor_readings_sensor', 'sensor_readings', ['sensor_id'], unique=False)
    op.alter_column('sensor_readings', 'sensor_type',
               existing_type=sa.Enum('temperature', 'humidity', 'gas', 'light', 'shock', 'gps', 'soil_moisture', 'pressure', 'ph', 'co2', 'noise', 'vibration', 'light_intensity', 'air_quality', 'motion', 'proximity', 'weight', 'flow', 'level', 'speed', 'direction', 'altitude', 'battery', 'signal_strength', 'other', name='sensortypeenum'),
               type_=sa.TEXT(),
               nullable=False)
    
    # Eliminar el enum de tipo de sensor
    sensortypeenum = sa.Enum('temperature', 'humidity', 'gas', 'light', 'shock', 'gps', 'soil_moisture', 'pressure', 'ph', 'co2', 'noise', 'vibration', 'light_intensity', 'air_quality', 'motion', 'proximity', 'weight', 'flow', 'level', 'speed', 'direction', 'altitude', 'battery', 'signal_strength', 'other', name='sensortypeenum')
    sensortypeenum.drop(op.get_bind())
    op.drop_column('sensor_readings', 'source_device')
    op.drop_column('sensor_readings', 'created_at')
    op.drop_column('sensor_readings', 'shock_detected')
    op.drop_column('sensor_readings', 'light_level')
    op.drop_column('sensor_readings', 'gas_level')
    op.drop_column('sensor_readings', 'humidity')
    op.drop_column('sensor_readings', 'temperature')
    op.drop_column('sensor_readings', 'product_id')
    op.add_column('qrs', sa.Column('url', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('qrs', sa.Column('is_active', sa.BOOLEAN(), server_default=sa.text('true'), autoincrement=False, nullable=True))
    op.add_column('qrs', sa.Column('qr_code', sa.TEXT(), autoincrement=False, nullable=False))
    op.create_unique_constraint('qrs_qr_code_key', 'qrs', ['qr_code'], postgresql_nulls_not_distinct=False)
    op.create_index('idx_qrs_product', 'qrs', ['product_id'], unique=False)
    op.create_index('idx_qrs_code', 'qrs', ['qr_code'], unique=False)
    op.drop_column('qrs', 'qr_type')
    op.drop_column('qrs', 'qr_metadata')
    op.drop_column('qrs', 'qr_hash')
    op.add_column('products', sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.create_index('idx_products_provider', 'products', ['provider_id'], unique=False)
    op.create_index('idx_products_name', 'products', ['name'], unique=False)
    op.create_index('idx_products_category', 'products', ['category'], unique=False)
    op.alter_column('products', 'is_hidden',
               existing_type=sa.BOOLEAN(),
               nullable=False,
               existing_server_default=sa.text('false'))
    op.add_column('impact_metrics', sa.Column('calculation_date', sa.DATE(), server_default=sa.text('CURRENT_DATE'), autoincrement=False, nullable=True))
    op.add_column('impact_metrics', sa.Column('product_id', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('impact_metrics', sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True))
    op.add_column('impact_metrics', sa.Column('unit', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('impact_metrics', sa.Column('value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
    op.add_column('impact_metrics', sa.Column('metric_type', sa.TEXT(), autoincrement=False, nullable=False))
    op.create_foreign_key('impact_metrics_product_id_fkey', 'impact_metrics', 'products', ['product_id'], ['id'])
    op.create_index('idx_impact_metrics_user', 'impact_metrics', ['user_id'], unique=False)
    op.create_index('idx_impact_metrics_type', 'impact_metrics', ['metric_type'], unique=False)
    op.create_index('idx_impact_metrics_product', 'impact_metrics', ['product_id'], unique=False)
    op.drop_column('impact_metrics', 'nutritional_consumption')
    op.drop_column('impact_metrics', 'waste_prevented_kg')
    op.drop_column('impact_metrics', 'local_support_eur')
    op.drop_column('impact_metrics', 'co2_saved_kg')
    op.add_column('blockchain_logs', sa.Column('product_id', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('blockchain_logs', sa.Column('transaction_hash', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('blockchain_logs', sa.Column('block_number', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('blockchain_logs', sa.Column('action', sa.TEXT(), autoincrement=False, nullable=False))
    op.add_column('blockchain_logs', sa.Column('data', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=False))
    op.create_foreign_key('blockchain_logs_product_id_fkey', 'blockchain_logs', 'products', ['product_id'], ['id'])
    op.create_index('idx_blockchain_logs_product', 'blockchain_logs', ['product_id'], unique=False)
    op.create_index('idx_blockchain_logs_hash', 'blockchain_logs', ['transaction_hash'], unique=False)
    op.create_index('idx_blockchain_logs_action', 'blockchain_logs', ['action'], unique=False)
    op.create_unique_constraint('blockchain_logs_transaction_hash_key', 'blockchain_logs', ['transaction_hash'], postgresql_nulls_not_distinct=False)
    op.drop_column('blockchain_logs', 'hash')
    op.drop_column('blockchain_logs', 'entity_id')
    op.drop_column('blockchain_logs', 'entity_type')
    
    # Eliminar el enum
    blockchainentitytypeenum = sa.Enum('product', 'transaction', 'sensor', name='blockchainentitytypeenum')
    blockchainentitytypeenum.drop(op.get_bind())
    # ### end Alembic commands ###
